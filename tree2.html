<script>
    function Node(value) {
        this.value = value;
        this.left = null;
        this.right = null;
    }
    const a = new Node('a');
    const b = new Node('b');
    const c = new Node('c');
    const d = new Node('d');
    const e = new Node('e');
    const f = new Node('f');
    const g = new Node('g');
    a.left = b;
    a.right = c;
    b.left = d;
    b.right = e;
    c.left = f;
    d.left = g;
    // 前序遍历
    function DLR(node) {
        if (!node) {
            return
        }
        console.log(node.value); //先遍历自己
        DLR(node.left); //再遍历左子树
        DLR(node.right); //再遍历右子树

    }
    // 中序遍历
    function LDR(node) {
        if (!node) {
            return
        }
        LDR(node.left); //先遍历左子树
        console.log(node.value); //再遍历自己
        LDR(node.right); //再遍历右子树
    }


    // 根据前序和中序遍历结果，得到一颗二叉树
    // substr方法：第一个参数表示开始的下标， 第二个参数选取参数的长度   如果第二个参数没有则表示取到结尾
    // substring与substr方法不同的是，substring方法，第一个参数表示开始的下标，第二个参数表示结束的下标(不包括)  substr方法已经弃用，不推荐使用 
    function getTree(dlr, ldr) {
        if (dlr.length === 0 && ldr.length === 0) {
            return null
        }
        const root = new Node(dlr[0])  //根节点
        const nodeIndex = ldr.indexOf(root.value) //根节点在中序中的下标
        const leftLDR = ldr.substring(0, nodeIndex) //左子树的中序
        const rightLDR = ldr.substring(nodeIndex + 1) //右子树的中序
        const leftDLR = dlr.substring(1, leftLDR.length + 1) //左子树的前序
        const rightDLR = dlr.substring(nodeIndex + 1) //右子树的前序
        root.left = getTree(leftDLR, leftLDR)
        root.right = getTree(rightDLR, rightLDR)
        return root
    }
    const node = getTree("ABDGECF", "GDBEAFC")
    console.log(node, 'node');



    // 计算树的深度
    function getDeep(node) {
        if (!node) {
            return 0
        }
        return 1 + Math.max(getDeep(node.left), getDeep(node.right))
    }

    // 查询树  
    // 1.深度优先搜索
    function deepSearch(node, target) {
        if (!node) {
            return false
        }
        // 如果自己就是
        if (node.value === target) {
            return true
        }
        // 如果左边是
        if (deepSearch(node.left, target)) {
            return true
        }
        // 如果左边的也都不是
        return deepSearch(node.right, target)
    }
    // 2.广度优先搜索
    function breadthSearch(node, target) {
        // 辅助函数
        function _breadthSearch(nodes) {
            // 如果没有这个节点，那就返回
            if (!nodes.length) {
                return false
            }
            const nextNodes = []
            // 遍历这一层的节点
            for (let i = 0; i < nextNodes.length; i++) {
                // 如果是这个，那就返回true
                if (nodes[i].value === target) {
                    return true
                }
                // 如果这个节点左边有东西，那就加入到下一层的节点
                if (nodes[i].left) {
                    nextNodes.push(nodes[i].left)
                }
                // 如果这个节点右边有东西，那也加入到下一层的节点
                if (nodes[i].right) {
                    nextNodes.push(nodes[i].right)
                }
            }
            return _breadthSearch(nextNodes)
        }
        return _breadthSearch([node])
    }


    // 比较两棵二叉树，得到他们的差异
    const node1 = getTree("ABDGECF", "GDBEAFC")
    const node2 = getTree("AKDECFT", "DKEAFCT")


    function diff(node1, node2) {
        const result = []
        // 两个节点都没没有值，不可能有差异
        if (!node1 && !node2) {
            return result
        }
        if (!node1 && node2) {
            result.push({
                type: "add",
                from: null,
                to: node2
            })  //这种情况不需要继续往后比较
        }
        if (node1 && !node2) {
            result.push({
                type: "delete",
                from: node1,
                to: null
            })  //这种情况不需要继续往后比较
        }
        if (node1.value !== node2.value) {
            result.push({
                type: "change",
                from: node1,
                to: node2
            })  //这种情况要继续往后比较  不能停止
        }
        const leftDiff = diff(node1.left, node2.left) //左树的差异
        const rightDiff = diff(node1.right, node2.right) //右树的差异
        return [...result, ...leftDiff, ...rightDiff]//合并差异的另一种写法
    }
    const result = diff(node1, node2)
    console.log(result, 'result');

</script>